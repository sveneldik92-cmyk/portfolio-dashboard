<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Transactions converter</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    :root { color-scheme: light; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; line-height: 1.35; }
    .card { max-width: 980px; border: 1px solid #e5e7eb; border-radius: 16px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,.04); }
    h1 { margin: 0 0 8px; font-size: 20px; }
    p { margin: 6px 0; color: #374151; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; }
    label { font-size: 12px; color: #374151; font-weight: 600; display: block; margin-bottom: 6px; }
    input[type="file"], textarea { width: 100%; border: 1px solid #e5e7eb; border-radius: 12px; padding: 10px; }
    textarea { min-height: 92px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
    button { border: 1px solid #e5e7eb; background: #111827; color: white; padding: 10px 12px; border-radius: 12px; cursor: pointer; font-weight: 600; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .muted { color:#6b7280; font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .ok { color:#065f46; }
    .bad { color:#991b1b; }
    pre { white-space: pre; overflow: auto; background:#0b1220; color:#e5e7eb; padding: 12px; border-radius: 12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px){ .grid { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <div class="card">
    <h1>Transactions converter → <span class="mono">transactions.csv</span></h1>
    <p>This converts DEGIRO exports into the column format required by <span class="mono">dashboard5.html</span>. It supports:</p>
    <ul class="muted" style="margin: 6px 0 0 18px;">
      <li><span class="mono">Transactions.csv</span> with Dutch headers (Datum, Product, Aantal, Koers, …).</li>
      <li>The “Order reference / Order type / Execution price” dividend report format shown in your screenshot.</li>
    </ul>
    <p class="mono muted" style="margin-top: 6px;">Date, Ticker, Type, Quantity, Price, Fee, Currency, Amount, Name, Account</p>
    <p class="muted">Notes: Date is converted to <span class="mono">YYYY-MM-DD</span>. BUY/SELL is inferred from the sign of <span class="mono">Aantal</span> or <span class="mono">Order type</span>. Dividends are exported as <span class="mono">DIV</span> with <span class="mono">Amount</span> = Net proceeds.</p>

    <div class="grid">
      <div>
        <label for="inFile">1) Choose DEGIRO CSV or XLSX</label>
        <input id="inFile" type="file" accept=".csv,.xlsx,text/csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />
        <p class="muted">Both the Dutch “Transactions.csv” and the dividend report export are supported, as CSV or XLSX.</p>
      </div>

      <div>
        <label for="mapFile">2) Optional: upload an ISIN→Ticker mapping CSV</label>
        <input id="mapFile" type="file" accept=".csv,text/csv" />
        <p class="muted">If you want real online prices, map ISINs to Stooq-style symbols (e.g. <span class="mono">IE00B3XXRP09 → VUSA.UK</span>). Mapping CSV can be 2 columns (ISIN,Ticker) or have headers.</p>
      </div>
    </div>

    <div class="row">
      <div style="flex:1 1 420px">
        <label for="mapText">Or paste mapping (ISIN,Ticker per line)</label>
        <textarea id="mapText" placeholder="IE00B3XXRP09,VUSA.UK&#10;IE0032077012,EQQQ.FR"></textarea>
        <div class="muted">If both mapping file and pasted mapping exist, pasted mapping wins.</div>
      </div>
      <div style="flex:0 0 240px">
        <label>&nbsp;</label>
        <button id="convertBtn" disabled>Convert & download</button>
        <p id="status" class="muted" style="margin-top:10px">Pick an input file…</p>
      </div>
    </div>

    <div style="margin-top: 14px">
      <label>Preview (first ~20 lines)</label>
      <pre id="preview">(nothing yet)</pre>
    </div>
  </div>

<script>
  // ---------- tiny CSV reader (handles quotes, commas, CRLF) ----------
  function parseCSV(text){
    const rows = [];
    let row = [];
    let cur = '';
    let inQuotes = false;

    for (let i=0; i<text.length; i++){
      const c = text[i];

      if (inQuotes){
        if (c === '"'){
          const next = text[i+1];
          if (next === '"'){ cur += '"'; i++; }
          else inQuotes = false;
        } else cur += c;
        continue;
      }

      if (c === '"'){ inQuotes = true; continue; }
      if (c === ','){ row.push(cur); cur=''; continue; }
      if (c === '\n'){
        row.push(cur); cur='';
        if (row.some(x => String(x||'').trim() !== '')) rows.push(row);
        row = [];
        continue;
      }
      if (c === '\r') continue;

      cur += c;
    }
    row.push(cur);
    if (row.some(x => String(x||'').trim() !== '')) rows.push(row);
    return rows;
  }

  function normHeader(s){
    return String(s||'').trim().toLowerCase().replace(/\s+/g,'').replace(/[_-]/g,'');
  }

  function parseNumEU(x){
    if (x == null) return null;
    let s = String(x).trim();
    if (!s) return null;
    s = s.replace(/[€$£]/g,'').replace(/\s/g,'');
    let neg = false;
    if (s.startsWith('(') && s.endsWith(')')){ neg=true; s=s.slice(1,-1); }
    // Dutch style: 1.234,56
    if (s.includes(',') && s.includes('.')){
      if (s.lastIndexOf(',') > s.lastIndexOf('.')) s = s.replace(/\./g,'').replace(',', '.');
      else s = s.replace(/,/g,''); // 1,234.56
    } else if (s.includes(',')){
      s = s.replace(/\./g,'').replace(',', '.');
    } else {
      s = s.replace(/,/g,'');
    }
    const v = Number(s);
    if (!Number.isFinite(v)) return null;
    return neg ? -v : v;
  }

  function toISODate(s){
    const t = String(s||'').trim();
    if (!t) return null;
    let m = t.match(/^(\d{2})-(\d{2})-(\d{4})$/);
    if (m) return `${m[3]}-${m[2]}-${m[1]}`;
    m = t.match(/^(\d{1,2})[\/.](\d{1,2})[\/.](\d{4})$/);
    if (m) return `${m[3]}-${String(m[2]).padStart(2,'0')}-${String(m[1]).padStart(2,'0')}`;
    m = t.match(/^(\d{1,2})\s+([A-Za-z\.]+)\s+(\d{4})/);
    if (m){
      const day = String(m[1]).padStart(2,'0');
      const monthKey = m[2].toLowerCase().replace('.', '').slice(0,3);
      const monthMap = {
        jan: '01', feb: '02', mrt: '03', mar: '03', apr: '04', mei: '05', may: '05',
        jun: '06', jul: '07', aug: '08', sep: '09', okt: '10', oct: '10', nov: '11', dec: '12'
      };
      const mm = monthMap[monthKey];
      if (!mm) return null;
      return `${m[3]}-${mm}-${day}`;
    }
    return null;
  }

  function csvEscape(v){
    const s = String(v ?? '');
    if (/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }

  function downloadText(filename, text){
    const blob = new Blob([text], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 2000);
  }

  async function readFileText(file){
    return await file.text();
  }

  async function readFileArrayBuffer(file){
    return await file.arrayBuffer();
  }

  // ---------- mapping helpers ----------
  function parseMappingFromText(text){
    const map = new Map();
    const lines = String(text||'').split(/\r?\n/);
    for (const line of lines){
      const t = line.trim();
      if (!t || t.startsWith('#')) continue;
      const parts = t.split(',').map(x => x.trim());
      if (parts.length < 2) continue;
      const isin = parts[0].toUpperCase();
      const ticker = parts[1].toUpperCase();
      if (isin && ticker) map.set(isin, ticker);
    }
    return map;
  }

  function parseMappingCsv(csvText){
    const rows = parseCSV(csvText);
    if (!rows.length) return new Map();
    const header = rows[0].map(normHeader);
    // detect headered vs 2-col raw
    let iIsin = header.indexOf('isin');
    let iTicker = header.indexOf('ticker');
    if (iTicker < 0) iTicker = header.indexOf('symbol');
    const map = new Map();

    const start = (iIsin >= 0 && iTicker >= 0) ? 1 : 0;
    for (let r=start; r<rows.length; r++){
      const row = rows[r];
      const isin = String(row[iIsin >= 0 ? iIsin : 0] || '').trim().toUpperCase();
      const ticker = String(row[iTicker >= 0 ? iTicker : 1] || '').trim().toUpperCase();
      if (isin && ticker) map.set(isin, ticker);
    }
    return map;
  }

  // ---------- main conversion ----------
  function findHeaderRow(rows, requiredHeaders){
    for (let i = 0; i < rows.length; i++){
      const header = rows[i].map(normHeader);
      const ok = requiredHeaders.every((h) => header.includes(normHeader(h)));
      if (ok) return i;
    }
    return -1;
  }

  function detectCurrency(value, fallback='EUR'){
    const s = String(value || '');
    if (s.includes('€')) return 'EUR';
    if (s.includes('$')) return 'USD';
    if (s.includes('£')) return 'GBP';
    if (s.includes('CHF')) return 'CHF';
    return fallback;
  }

  function normalizeOrderType(value){
    const t = String(value || '').trim().toLowerCase();
    if (!t) return null;
    if (t.includes('dividend')) return 'DIV';
    if (t.includes('buy') || t.includes('koop')) return 'BUY';
    if (t.includes('sell') || t.includes('verkoop')) return 'SELL';
    if (t.includes('deposit') || t.includes('storting')) return 'DEPOSIT';
    if (t.includes('withdraw') || t.includes('opname')) return 'WITHDRAW';
    return null;
  }

  function buildTickerCandidate(isinToTicker, isin, name, instrument){
    if (isinToTicker){
      if (isin && isinToTicker.has(isin)) return isinToTicker.get(isin);
      const instKey = String(instrument || '').trim().toUpperCase();
      if (instKey && isinToTicker.has(instKey)) return isinToTicker.get(instKey);
    }
    if (isin) return isin;
    if (instrument){
      const token = String(instrument).trim().split(/\s+/)[0];
      if (token) return token.toUpperCase();
    }
    if (name) return name;
    return 'UNKNOWN';
  }

  function convertDegiroTransactionsCsv(rows, isinToTicker, headerRow){
    const headerRaw = rows[headerRow];
    const header = headerRaw.map(normHeader);

    const find = (key) => header.indexOf(normHeader(key));

    const iDate  = find('Datum');
    const iName  = find('Product');
    const iIsin  = find('ISIN');
    const iQty   = find('Aantal');
    const iPrice = find('Koers');
    const iLocalVal = find('Lokale waarde');
    const iValEur = find('Waarde EUR');
    const iFx    = find('Wisselkoers');
    const iAutoFx = find('AutoFX Kosten');
    const iFeesEur = find('Transactiekosten en/of kosten van derden EUR');

    if (iDate < 0 || iQty < 0 || iPrice < 0 || iIsin < 0){
      throw new Error('Missing required DEGIRO columns. Expected at least: Datum, ISIN, Aantal, Koers.');
    }

    // currency columns are blank headers directly after Koers and after Lokale waarde
    const iCcyAfterPrice = (headerRaw[iPrice+1] === '') ? (iPrice+1) : -1;
    const iCcyAfterLocal = (iLocalVal >= 0 && headerRaw[iLocalVal+1] === '') ? (iLocalVal+1) : -1;

    const outRows = [];
    for (let r=headerRow+1; r<rows.length; r++){
      const row = rows[r];
      const iso = toISODate(row[iDate]);
      if (!iso) continue;

      const qRaw = parseNumEU(row[iQty]);
      if (!qRaw || qRaw === 0) continue;

      const type = (qRaw > 0) ? 'BUY' : 'SELL';
      const qty = Math.abs(qRaw);

      const price = parseNumEU(row[iPrice]);
      if (price == null) continue;

      const isin = String(row[iIsin] || '').trim().toUpperCase();
      const name = iName >= 0 ? String(row[iName] || '').trim() : '';
      const ccy = String(
        (iCcyAfterLocal >= 0 ? row[iCcyAfterLocal] : '') ||
        (iCcyAfterPrice >= 0 ? row[iCcyAfterPrice] : '') ||
        'EUR'
      ).trim().toUpperCase() || 'EUR';

      // FX: prefer Wisselkoers, else derive from Lokale waarde / Waarde EUR
      const localVal = iLocalVal >= 0 ? parseNumEU(row[iLocalVal]) : null;
      const valEur = iValEur >= 0 ? parseNumEU(row[iValEur]) : null;
      let fx = iFx >= 0 ? parseNumEU(row[iFx]) : null;
      if (fx == null && localVal != null && valEur != null && valEur !== 0){
        fx = Math.abs(localVal) / Math.abs(valEur);
      }

      const feeEur = Math.abs((iFeesEur >= 0 ? (parseNumEU(row[iFeesEur]) || 0) : 0) + (iAutoFx >= 0 ? (parseNumEU(row[iAutoFx]) || 0) : 0));
      const feeLocal = (ccy === 'EUR' || !fx) ? feeEur : (feeEur * fx);

      const ticker = buildTickerCandidate(isinToTicker, isin, name, '');

      outRows.push([
        iso,
        ticker,
        type,
        String(qty),
        String(price),
        String(feeLocal || 0),
        ccy,
        '',
        name,
        'DEGIRO'
      ]);
    }
    return outRows;
  }

  function convertDegiroDividendReport(rows, isinToTicker, headerRow){
    const headerRaw = rows[headerRow];
    const header = headerRaw.map(normHeader);
    const find = (key) => header.indexOf(normHeader(key));

    const iDate = find('Date');
    const iOrderType = find('Order type');
    const iQty = find('Quantity');
    const iPrice = find('Execution price');
    const iInstrument = find('Instrument');
    const iFees = find('Fees');
    const iTaxes = find('Taxes withheld');
    const iNetProceeds = find('Net proceeds');
    const iNetUnits = find('Net units');

    if (iDate < 0 || iOrderType < 0 || iInstrument < 0){
      throw new Error('Missing required columns in dividend report format.');
    }

    const outRows = [];
    for (let r=headerRow+1; r<rows.length; r++){
      const row = rows[r];
      const iso = toISODate(row[iDate]);
      if (!iso) continue;

      const normType = normalizeOrderType(row[iOrderType]);
      if (!normType) continue;

      const instrument = String(row[iInstrument] || '').trim();
      const ticker = buildTickerCandidate(isinToTicker, '', instrument, instrument);

      const qty = iQty >= 0 ? parseNumEU(row[iQty]) : null;
      const netUnits = iNetUnits >= 0 ? parseNumEU(row[iNetUnits]) : null;
      const quantity = qty ?? netUnits ?? null;

      const price = iPrice >= 0 ? parseNumEU(row[iPrice]) : null;
      const fee = Math.abs((iFees >= 0 ? (parseNumEU(row[iFees]) || 0) : 0) + (iTaxes >= 0 ? (parseNumEU(row[iTaxes]) || 0) : 0));
      const netProceeds = iNetProceeds >= 0 ? parseNumEU(row[iNetProceeds]) : null;
      const currency = detectCurrency(row[iNetProceeds] || row[iPrice], 'EUR');

      if ((normType === 'BUY' || normType === 'SELL') && (quantity == null || price == null)) continue;
      if ((normType === 'DIV' || normType === 'DEPOSIT' || normType === 'WITHDRAW') && netProceeds == null) continue;

      outRows.push([
        iso,
        ticker,
        normType,
        quantity != null ? String(Math.abs(quantity)) : '',
        price != null ? String(price) : '',
        String(fee || 0),
        currency,
        netProceeds != null ? String(netProceeds) : '',
        instrument,
        'DEGIRO'
      ]);
    }
    return outRows;
  }

  function convertDegiroToDashboard(rows, isinToTicker){
    if (!rows.length) throw new Error('Input file is empty.');

    const dividendHeaderRow = findHeaderRow(rows, ['Order reference', 'Order type', 'Execution price']);
    const txHeaderRow = findHeaderRow(rows, ['Datum', 'ISIN', 'Aantal', 'Koers']);

    let outRows = [];
    if (dividendHeaderRow >= 0){
      outRows = convertDegiroDividendReport(rows, isinToTicker, dividendHeaderRow);
    } else if (txHeaderRow >= 0){
      outRows = convertDegiroTransactionsCsv(rows, isinToTicker, txHeaderRow);
    } else {
      throw new Error('Unrecognized DEGIRO format. Please export Transactions.csv or the dividend report format.');
    }

    if (!outRows.length) throw new Error('No usable rows found in the DEGIRO export.');

    const header = ['Date','Ticker','Type','Quantity','Price','Fee','Currency','Amount','Name','Account'];
    const csvRows = [header, ...outRows];

    const csv = csvRows.map(r => r.map(csvEscape).join(',')).join('\n');
    return { csv, preview: csv.split('\n').slice(0, 20).join('\n'), rows: outRows.length };
  }

  // ---------- wire UI ----------
  const inFile = document.getElementById('inFile');
  const mapFile = document.getElementById('mapFile');
  const mapText = document.getElementById('mapText');
  const btn = document.getElementById('convertBtn');
  const status = document.getElementById('status');
  const preview = document.getElementById('preview');

  function setStatus(msg, bad=false){
    status.textContent = msg;
    status.className = bad ? 'muted bad' : 'muted ok';
  }

  function refreshButton(){
    btn.disabled = !inFile.files || !inFile.files[0];
    if (!btn.disabled) setStatus('Ready to convert.', false);
    else { status.textContent = 'Pick an input file…'; status.className = 'muted'; }
  }

  inFile.addEventListener('change', refreshButton);
  refreshButton();

  btn.addEventListener('click', async () => {
    try {
      btn.disabled = true;
      setStatus('Reading files…', false);

      const rows = await readInputRows(inFile.files[0]);

      // mapping: paste wins; else file; else none
      let mapping = new Map();
      const pasted = mapText.value.trim();
      if (pasted){
        mapping = parseMappingFromText(pasted);
      } else if (mapFile.files && mapFile.files[0]){
        const mapCsv = await readFileText(mapFile.files[0]);
        mapping = parseMappingCsv(mapCsv);
      }

      setStatus('Converting…', false);
      const { csv, preview: pv, rows: rowCount } = convertDegiroToDashboard(rows, mapping);

      preview.textContent = pv;
      setStatus(`Done. Converted ${rowCount} rows. Downloading…`, false);

      downloadText('transactions.csv', csv);
    } catch (e){
      preview.textContent = '(nothing)';
      setStatus(String(e && e.message ? e.message : e), true);
    } finally {
      btn.disabled = false;
    }
  });

  async function readInputRows(file){
    const name = String(file.name || '').toLowerCase();
    if (name.endsWith('.xlsx')){
      if (typeof XLSX === 'undefined'){
        throw new Error('XLSX parser unavailable. Please try a CSV export instead.');
      }
      const buffer = await readFileArrayBuffer(file);
      const workbook = XLSX.read(buffer, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      if (!sheetName) throw new Error('XLSX file has no sheets.');
      const sheet = workbook.Sheets[sheetName];
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false, blankrows: false, defval: '' });
      return rows;
    }
    const text = await readFileText(file);
    return parseCSV(text);
  }
</script>
</body>
</html>
